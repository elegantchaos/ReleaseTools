[comment]: <> (Header Generated by ActionStatus 2.0.6 - 478)

[![Test results][tests shield]][actions] [![Latest release][release shield]][releases] [![swift 6.2 shield]][swift] ![Platforms: macOS][platforms shield]

[release shield]: https://img.shields.io/github/v/release/elegantchaos/ReleaseTools
[platforms shield]: https://img.shields.io/badge/platforms-macOS-lightgrey.svg?style=flat "macOS"
[tests shield]: https://github.com/elegantchaos/ReleaseTools/workflows/Tests/badge.svg
[swift 6.2 shield]: https://img.shields.io/badge/swift-6.2-F05138.svg "Swift 6.2"

[swift]: https://swift.org
[releases]: https://github.com/elegantchaos/ReleaseTools/releases
[actions]: https://github.com/elegantchaos/ReleaseTools/actions

[comment]: <> (End of ActionStatus Header)


My own personal tools to perform various release-related tasks for iOS and macOS applications.

Think [Fastlane](https://fastlane.tools/), but much simpler (and consequently much less capable).

The main activities supported are:
- calculating a build number and injecting it whilst building or archiving
- exporting and uploading an archive to the App Store portal
- (or) notarising and building a Sparkle feed for an externally distributed macOS app.

**Note**: _The notarisation/sparkle path is one I used it extensively for a while, but I haven't needed it recently. It may need a little bit of fixing up, so let me know if you encounter problems. It isn't likely to be hard to fix._

## Uploading To App Store

When publishing via the App Store Connect portal, the main command is:

```shell
rt submit
```

This builds an archive, exports it, and uploads it to the app store, using credentials you've previously configured.

### Granularity

The `submit` command is the equivalent of performing this sequence of smaller commands:

```shell
    rt archive
    rt export
    rt upload
```

The effect of these commands is:
- archive: build an archive
- export: export from output of `archive`
- upload: upload the output of `export` to the app store connect portal

Normally you can just use the `submit` command, but the individual steps
can also executed in order if you want more control over the process, or
if you need to restart the halfway through (eg run the export again
without rebuilding or exporting the archive).

Some other tasks are supported by rt (see below), but haven't been used for a while
and may need some debugging. These are mostly aimed at external
distribution of a macOS application via a website, and include support
for notarizing and updating an appcast feed suitable for Sparkle.

# Build Number

ReleaseTools can automatically calculate and inject a build number into your application.

You can either do this only when making an archive for distribution (running `rt archive` or `rt submit`), or every time you make a build. 

The former is more efficient, but means that the build number is not available when running from Xcode. I generally use this approach.

The latter requires running `rt update-build` in a script phase, and so slightly increases the build times for normal builds. 

## When Archiving

When archiving, the injected build number is based solely on the value of the git version tag attached to the current HEAD commit.

This version must be in the form `vX.Y.Z-BUILD` where `X.Y.Z` is the semantic version, and `BUILD` is the build number.

If there is not a tag in this format at HEAD, the `archive`/`submit` commands will refuse to run.

If the tag is present, then it is parsed and used to set the value of two constants:
- CURRENT_PROJECT_VERSION: the calculated build number
- CURRENT_PROJECT_COMMIT: the full git commit hash

The archive command then generates a `VersionInfo.h` header file, and overrides some build settings on the command line when invoking `xcodebuild`, so that the header file is included by the Info.plist preprocessor.

The build settings supplied to `xcodebuild` on the command line are:
- INFOPLIST_PREFIX_HEADER: set to the location of the generated `VersionInfo.h` file
- INFOPLIST_PREPROCESS: set to YES
- CURRENT_PROJECT_VERSION: set to the calculated build number
- CURRENT_PROJECT_COMMIT: the full git commit hash

By turning on the Info.plist preprocessing, and using our generated header file, we cause any occurences of the strings `CURRENT_PROJECT_VERSION` and `CURRENT_PROJECT_COMMIT` in the Info.plist file to be replaced with the values of the corresponding constants.

By also defining the two variables directly as command line arguments when we invoke xcodebuild, we also allow any occurences of `${CURRENT_PROJECT_VERSION}` and `${CURRENT_PROJECT_COMMIT}` to be replaced in other build settings or build scripts.

## When Building

When using the `update-build` command, the requirement for there to be a version tag on the HEAD commit is removed. 

If there is a tag on HEAD, we use it, but if not, we simply look for the highest version tag on any commit in the current branch, and speculatively add 1 to it. This is intended as a way to inject the likely future version number that will be used when we eventually submit the build.

Like the `archive` / `submit` commands, the `update-build` command generates a `VersionInfo.h` file.

It also optionally generates an `.xcconfig` file which defines the build settings `CURRENT_PROJECT_VERSION` and `CURRENT_PROJECT_COMMIT`, and have your project include that.

Finally, you can also specify the path of source and destination `.plist` files. A new copy of the source file will be written to the destination, with the latest build and commit values written into the `CFBundleVersion` and `Commit` keys.

## Incrementing The Build Number

ReleaseTools supports automatically incrementing the version tag, using the `rt tag` command.

This command finds the oldest previous tag in the correct format, increments the build number by one, and uses git to create and push a new tag.




# The Full Toolchain

The process of producing a release consists of a number of steps: archiving, exporting, notarizing, stapling, zipping, updating, regenerating an appcast, and publishing.  

ReleaseTools is designed to be easy to debug when something goes wrong, and so each step is broken down into separate command. This makes it possible to re-run some steps without having to start at the beginning each time.

There are also `--show-commands` and `--show-output` options which will echo the commands that the tool is running, and the output of those commands.

When everything is working smoothly, however, the steps are expected to be run one after the other, without the need for interaction. A shell script to run them all together in the correct order, for a macOS release being distributed via an external website, might look something like:

```shell
set -e
rt archive --show-commands
rt export
rt notarize
rt wait
rt compress
rt appcast --show-commands
rt publish
```
## Commands

More details of each command are given below:

### archive

Run `xcodebuild archive` to archive the application for distribution.

The scheme to build is either specified explicitly, or set previously by the `defaultScheme` setting in the `.rt.json` settings file for the project.

The archive is placed into: `.build/<platform>/archive.xcarchive`.

### export

Exports the application from the archive created with the `archive` command, and puts it into `/build/export`.

### notarize

Takes the app exported with the `export` command, zips it up, and uploads it to Apple for notarization.

If the upload succeeds, the Apple servers return an xml receipt containing a RequestUUID that we can use to check on the status later. This is stored in `.build/<platform>/export/receipt.xml`.

### upload

Takes the ipa exported with the `export` command, and uploads it to Apple Connect for review.

If the upload succeeds, the Apple servers return an xml receipt containing status message. This isn't of much use, but is stored in `.build/<platform>/export/receipt.xml`.

### wait

Requests the notarization status for the app from the Apple servers.

If the status is `success`, we copy the exported app from `.build/<platform>/exported` into `.build/<platform>/stapled`, and staple it with the notarization ticket.

If the status is `failed`, we abort with an error.

If the status is not yet known (notarization hasn't completed), we wait 10 seconds and check again.

This command will therefore not return until notarization has completed (or failed).

### compress

Compresses the app in `.build/<platform>/stapled` into a zip archive suitable for inclusion in the `appcast`.

This will have the name `<app>-v<version>-<build>.zip`, and will be copied into the location specified with the `--to=<path>` option.

A copy of the archive, with the name `<app>-latest.zip` is also placed in the location specified with the `--latest=<path>` option.

If these two locations aren't specified, we use the default layout, which is the equivalent of  `--to=Dependencies/Website` and `--latest=Dependencies/Website/updates`.

### appcast

Rebuilds the appcast file, using Sparkle's `generate_appcast` command, which it builds first if necessary.

The file is named `appcast.xml` and its location is specified with the `--to=<path>` option. 

If this option is not specified, we use the default layout, which is the equivalent of `--to=Dependencies/Website`.

The appcast is signed using a private DSA key which is expected to be in the keychain under the name `<scheme> Sparkle Key`.

If this key isn't found, it is generated, using Sparkle's `generate_keys` script, and imported into the keychain. Currently I can't find a way to give the imported key the right label, so this has to be done manually using the `Keychain Access` app.  

The public key is expected to be called `dsa_public.pem`, and be included in the `Resources/` folder of the app bundle.

In order to be able to build/run the various Sparkle tools, the Sparkle project is expected to be present in the Xcode workspace.

*Note:* it is necessary to pass the `--show-output` flag to this command, because it needs to access the keychain. If you don't do this, the command will sometimes hang (I believe because it's waiting for you to enter a password to allow keychain access).

### publish

Commits and publishes the latest changes to the website repo.

Assumes that the submodule defining the website which hosts the appcast is located at `Dependencies/Website`.

### update-build

This command can be used to inject the current build number
and commit hash into a C-style header file,
an xcconfig file, or an Info.plist file.

If you specify the `--header` option with a path to a `.h` file, it
will be replaced with generated content:

```c
#define CURRENT_PROJECT_BUILD <build>
#define CURRENT_PROJECT_COMMIT <hash>
```

containing the current build and hash values.

If you specify the `--config` option with a path to an `.xcconfig` file, it will be generated with the same values as above.

If you specify the `--plist` option with a path to a `.plist` file,
it will be generated, or updates, with two keys `CURRENT_PROJECT_BUILD` and `CURRENT_PROJECT_HASH`.

### submit

This performs the `archive`, `export` and `upload` commands in order.

It accepts the same options as those commands.

## Building

The tool is currently built using swift package manager: `swift build`.

You can build and run in a single line with `swift run rt <command> <args>`.

Alternatively you can build & install it somewhere, eg using [Mint](https://github.com/yonaskolb/Mint).


# Configuration

To cut down on the amount of configuration that you have to do, `rt` relies on naming conventions and defaults for a lot of things.

We expect you to run rt from the root of a project folder, and we look for a workspace in that folder with the same name as the folder. 

We also look for a scheme in that workspace with the same name, by default. 

So if your project is in a folder called `Foo`, we will use `Foo.xcworkspace` as the `-workspace` argument to xcodebuild, and `Foo` as the `-scheme` argument.

You can override the default scheme with the `--scheme=<name>` option, or with a setting in the optional `.rt.json` configuration file.

We support building for multiple platforms, but only one at a time. To tell rt which platform to build for, use an optional argument `--platform=macOS|iOS|tvOS|watchOS`. If you have only one supported platform, you can set it in the `.rt.json` file. If you don't supply the platform, it defaults to `macOS`.
