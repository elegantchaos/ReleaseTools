[comment]: <> (Header Generated by ActionStatus 2.0.6 - 478)

[![Test results][tests shield]][actions] [![Latest release][release shield]][releases] [![swift 6.2 shield]][swift] ![Platforms: macOS][platforms shield]

[release shield]: https://img.shields.io/github/v/release/elegantchaos/ReleaseTools
[platforms shield]: https://img.shields.io/badge/platforms-macOS-lightgrey.svg?style=flat "macOS"
[tests shield]: https://github.com/elegantchaos/ReleaseTools/workflows/Tests/badge.svg
[swift 6.2 shield]: https://img.shields.io/badge/swift-6.2-F05138.svg "Swift 6.2"

[swift]: https://swift.org
[releases]: https://github.com/elegantchaos/ReleaseTools/releases
[actions]: https://github.com/elegantchaos/ReleaseTools/actions

[comment]: <> (End of ActionStatus Header)


# Release Tools

A suite of tools to perform various release-related tasks.

When publishing via the App Store Connect portal, the main command is:

```shell
rt submit
```

This builds an archive, exports it, and uploads it to the app store.

It is the equivalent of performing this sequence:

```shell
    rt archive
    rt export
    rt upload
```

The effect of these commands is:
- archive: build an archive
- export: export from output of `archive`
- upload: upload the output of `export` to the app store connect portal

Normally you can just use the `submit` command, but the individual steps
can also executed in order if you want more control over the process, or
if you need to restart the halfway through (eg run the export again
without rebuilding or exporting the archive).

Some other tasks are supported by rt (see below), but haven't been used for a while
and may need some debugging. These are mostly aimed at external
distribution of a macOS application via a website, and include support
for notarizing and updating an appcast feed suitable for Sparkle.

## Build Number

ReleaseTools can automatically calculate and inject a build number into your application.

The injection is done in two ways:

- generating a VersionInfo.h header file
- overriding some build settings on the command line when invoking `xcodebuild`

The constants defined by the `VersionInfo.h` file are:
- CURRENT_PROJECT_VERSION: the calculated build number
- CURRENT_PROJECT_COMMIT: the full git commit hash

The build settings supplied on the command line are:
- INFOPLIST_PREFIX_HEADER: the path to the generated `VersionInfo.h` file
- INFOPLIST_PREPROCESS: set to YES
- CURRENT_PROJECT_VERSION: set to the calculated build number
- CURRENT_PROJECT_COMMIT: the full git commit hash

Using a combination of these values, it is possible to use the defined values in Info.plist via variable substitution,
and in other build settings or scripts.

There is also a separate `update-build` command which you can use to generate a header file, a plist file, and/or an xcconfig file, containing these values.

### Build Number Generation

There are two ways that the build number can be generated.

The default method uses a count of the commits (produced with `git rev-list --count HEAD`), and thus trends upwards as commits increase.

This is often sufficient, but the commit value stored is the actual git commit at `HEAD`, and so it can vary up or down when you switch branches. If you always publish from the same branch (eg `main`), this should not be a problem.

The other generation method uses git tags. It can be enabled by passing the `--increment-tag` flag, or setting `"incrementTag": true` in the `.rt.json` settings file for your project.

This method works by examining the git tags and finding the tag with the highest version in the format `vX.Y.Z-build-platform` where `platform` is the platform you are building for (eg `iOS`), `build` is the build number, and `X.Y.Z` is the semantic version of the product.

This tag is presumed to represent the highest in-use build number, and so the new build number is calculated by adding one to it.

These tags are automatically created and pushed to git if the `upload` command succeeds, and so each subsequent upload will be tagged with
a new higher build number, even if it happens on a different build machine.


## The Full Toolchain

The process of producing a release consists of a number of steps: archiving, exporting, notarizing, stapling, zipping, updating, regenerating an appcast, and publishing.  

When everything is working smoothly, the steps are expected to be run one after the other, without the need for interaction.

However, each step is broken down into separate command. This is done to make them easier to debug, and to make it possible to re-run some steps without having to start at the beginning each time.

A shell script to run them all together in the correct order, for a macOS release being distributed via an external website, might look something like:

```
set -e
rt archive --show-output
rt export
rt notarize
rt wait
rt compress
rt appcast --show-output
rt publish
```

More details of each command are given below:

### archive

Run `xcodebuild archive` to archive the application for distribution.

The scheme to build is either specified explicitly, or set previously by the `defaultScheme` setting in the `.rt.json` settings file for the project.

The archive is placed into: `.build/<platform>/archive.xcarchive`.

### export

Exports the application from the archive created with the `archive` command, and puts it into `/build/export`.

### notarize

Takes the app exported with the `export` command, zips it up, and uploads it to Apple for notarization.

If the upload succeeds, the Apple servers return an xml receipt containing a RequestUUID that we can use to check on the status later. This is stored in `.build/<platform>/export/receipt.xml`.

### upload

Takes the ipa exported with the `export` command, and uploads it to Apple Connect for review.

If the upload succeeds, the Apple servers return an xml receipt containing status message. This isn't of much use, but is stored in `.build/<platform>/export/receipt.xml`.

### wait

Requests the notarization status for the app from the Apple servers.

If the status is `success`, we copy the exported app from `.build/<platform>/exported` into `.build/<platform>/stapled`, and staple it with the notarization ticket.

If the status is `failed`, we abort with an error.

If the status is not yet known (notarization hasn't completed), we wait 10 seconds and check again.

This command will therefore not return until notarization has completed (or failed).

### compress

Compresses the app in `.build/<platform>/stapled` into a zip archive suitable for inclusion in the `appcast`.

This will have the name `<app>-v<version>-<build>.zip`, and will be copied into the location specified with the `--to=<path>` option.

A copy of the archive, with the name `<app>-latest.zip` is also placed in the location specified with the `--latest=<path>` option.

If these two locations aren't specified, we use the default layout, which is the equivalent of  `--to=Dependencies/Website` and `--latest=Dependencies/Website/updates`.

### appcast

Rebuilds the appcast file, using Sparkle's `generate_appcast` command, which it builds first if necessary.

The file is named `appcast.xml` and its location is specified with the `--to=<path>` option. 

If this option is not specified, we use the default layout, which is the equivalent of `--to=Dependencies/Website`.

The appcast is signed using a private DSA key which is expected to be in the keychain under the name `<scheme> Sparkle Key`.

If this key isn't found, it is generated, using Sparkle's `generate_keys` script, and imported into the keychain. Currently I can't find a way to give the imported key the right label, so this has to be done manually using the `Keychain Access` app.  

The public key is expected to be called `dsa_public.pem`, and be included in the `Resources/` folder of the app bundle.

In order to be able to build/run the various Sparkle tools, the Sparkle project is expected to be present in the Xcode workspace.

*Note:* it is necessary to pass the `--show-output` flag to this command, because it needs to access the keychain. If you don't do this, the command will sometimes hang (I believe because it's waiting for you to enter a password to allow keychain access).

### publish

Commits and publishes the latest changes to the website repo.

Assumes that the submodule defining the website which hosts the appcast is located at `Dependencies/Website`.

### update-build

This command can be used to inject the current build number
and commit hash into a C-style header file,
an xcconfig file, or an Info.plist file.

If you specify the `--header` option with a path to a `.h` file, it
will be replaced with generated content:

```c
#define CURRENT_PROJECT_BUILD <build>
#define CURRENT_PROJECT_COMMIT <hash>
```

containing the current build and hash values.

If you specify the `--config` option with a path to an `.xcconfig` file, it will be generated with the same values as above.

If you specify the `--plist` option with a path to a `.plist` file,
it will be generated, or updates, with two keys `CURRENT_PROJECT_BUILD` and `CURRENT_PROJECT_HASH`.


## Building

The tool is currently built using swift package manager: `swift build`.

You can build and run in a single line with `swift run rt <command> <args>`.

Alternatively you can build & install it somewhere, eg using [Mint](https://github.com/yonaskolb/Mint).


## Naming Conventions

To cut down on the amount of configuration that you have to do, `rt` relies on naming conventions and defaults for a lot of things.

We expect a standard project layout. If your project is called `Foo`, the layout would be: 

```
Foo/
    Foo.xcworkspace
    Foo.xcodeproj
    Sources/
        Foo/
            Resources/
```
        
From this we derive some other values:
        
- *package*: this is expected to be the same name as the containing folder, so if your project is in a folder `~/Projects/foo`, the package will be `foo`.
- *workspace*: this is expected to be the same name as the package, so if your package is `foo`, the workspace will be `foo.xcworkspace`.
- *platform*: this is either supplied as `--platform=macOS|iOS|tvOS|watchOS` or defaults to `macOS`
- *scheme*: this is supplied as `--scheme=<name>`; a default can be specified in `.rt.json`.
